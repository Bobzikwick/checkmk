#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# Copyright (C) 2019 tribe29 GmbH - License: GNU General Public License v2
# This file is part of Checkmk (https://checkmk.com). It is subject to the terms and
# conditions defined in the file COPYING, which is part of this source code package.

from typing import Callable, Dict, List, Mapping, Optional, Tuple, Union
from cmk.base.plugins.agent_based.agent_based_api.v1.type_defs import StringTable

import time

Converter = Union[str, Tuple[str, Callable[[str], Union[str, float, None]]]]

# Example output:
# BIOS Information
# 	Vendor: LENOVO
# 	Version: 6FET49WW (1.19 )
# 	Release Date: 10/17/2008
# 	Address: 0xE0000
# 	Runtime Size: 128 kB
# 	ROM Size: 8192 kB
# 	Characteristics:
# 		PCI is supported
# 		PC Card (PCMCIA) is supported
# 		PNP is supported
# 		BIOS is upgradeable
# 		BIOS shadowing is allowed
# 		ESCD support is available
# 		Boot from CD is supported
# 		Selectable boot is supported
# 		BIOS ROM is socketed
# 		EDD is supported
# 		ACPI is supported
# 		USB legacy is supported
# 		BIOS boot specification is supported
# 		Targeted content distribution is supported
# 	BIOS Revision: 1.25
# 	Firmware Revision: 1.1
#
# System Information
# 	Manufacturer: LENOVO
# 	Product Name: 4061AR7
# 	Version: ThinkPad W500
# 	Serial Number: L3AFB3L
# 	UUID: AD137E01-4A86-11CB-A580-BE0E287D2679
# 	Wake-up Type: Power Switch
# 	SKU Number: Not Specified
# 	Family: ThinkPad W500
#
# ... any many other sections...


# Note: on Linux \t is replaced by : and then the split
# is done by :. On Windows the \t comes 1:1 and no splitting
# is being done. So we need to split manually here
def inv_dmidecode(info: StringTable) -> None:
    # Note: we cannot use a dict here, we may have multiple subsections with the same title
    subsections: List[Tuple[str, StringTable]] = []
    current_lines: StringTable = []  # these will not be used
    for line in info:
        # Windows plugin keeps tabs and has no separator
        if len(line) == 1:
            parts = line[0].replace("\t", ":").split(":")
            line = [x.strip() for x in parts]

        if len(line) == 1:
            current_lines = []
            subsections.append((line[0], current_lines))
        else:
            current_lines.append(line[1:])

    for title, lines in subsections:
        inv_dmidecode_parse_section(title, lines)


def inv_dmidecode_parse_section(name: str, lines: List[List[str]]) -> None:
    lines = [[w.strip() for w in words] for words in lines]
    if name == "BIOS Information":
        inv_dmidecode_parse_bios(lines)
    elif name == "System Information":
        inv_dmidecode_parse_system(lines)
    elif name == "Chassis Information":
        inv_dmidecode_parse_chassis(lines)
    elif name == "Processor Information":
        inv_dmidecode_parse_processor(lines)


#    elif name == "Memory Controller Information":
#        inv_dmidecode_parse_mem_controller(lines)
#    elif name == "Memory Module Information":
#        inv_dmidecode_parse_mem_module(lines)
    elif name == "Physical Memory Array":
        inv_dmidecode_parse_physical_mem_array(lines)
    elif name == "Memory Device":
        inv_dmidecode_parse_mem_device(lines)

    # TODO: Summe ueber alle Arrays ausrechnen


def inv_dmidecode_parse_date(value: str) -> Optional[float]:
    try:
        # 10/17/2008
        return time.mktime(time.strptime(value, "%m/%d/%Y"))
    except Exception:
        return None


def inv_dmidecode_parse_bios(lines: List[List[str]]) -> None:
    inv_tree("software.bios.").update(
        _make_dict(
            lines, {
                "Vendor": "vendor",
                "Version": "version",
                "Release Date": ("date", inv_dmidecode_parse_date),
                "BIOS Revision": "revision",
                "Firmware Revision": "firmware",
            }))


def inv_dmidecode_parse_system(lines: List[List[str]]) -> None:
    inv_tree("hardware.system.").update(
        _make_dict(
            lines, {
                "Manufacturer": "manufacturer",
                "Product Name": "product",
                "Version": "version",
                "Serial Number": "serial",
                "UUID": "uuid",
                "Family": "family",
            }))


def inv_dmidecode_parse_chassis(lines: List[List[str]]) -> None:
    inv_tree("hardware.chassis.").update(
        _make_dict(lines, {
            "Manufacturer": "manufacturer",
            "Type": "type",
        }))


# Note: This node is also being filled by lnx_cpuinfo
def inv_dmidecode_parse_processor(lines: List[List[str]]) -> None:
    vendor_map = {
        "GenuineIntel": "intel",
        "Intel(R) Corporation": "intel",
        "AuthenticAMD": "amd",
    }
    cpu_info = _make_dict(
        lines, {
            "Manufacturer": ("vendor", lambda v: vendor_map.get(v, v)),
            "Max Speed": ("max_speed", dmidecode_parse_speed),
            "Voltage": ("voltage", dmidecode_parse_voltage),
            "Status": "status",
        })

    if cpu_info.pop("Status", "") == "Unpopulated":
        # Only update our CPU information if the socket is populated
        return

    inv_tree("hardware.cpu.").update(cpu_info)


# def inv_dmidecode_parse_mem_controller(lines: List[List[str]]) -> None:
#     # TODO: Can we have multiple memory controllers
#     node = inv_tree("hardware.memory.")
#     for line in lines:
#         if line[0] == "Maximum Memory Module Size":
#             node["max_module_size"] = dmidecode_parse_size(line[1])
#         elif line[0] == "Maximum Total Memory Size":
#             node["max_memory_size"] = dmidecode_parse_size(line[1])
#         elif line[0] == "Memory Module Voltage":
#             node["module_voltage"] = dmidecode_parse_voltage(line[1])
#
# def inv_dmidecode_parse_mem_module(lines: List[List[str]]) -> None:
#     node = inv_tree_list("hardware.memory.modules:")
#     module = {}
#     node.append(module)
#     for line in lines:
#         if line[0] == "Socket Designation":
#             module["disignation"] = line[1]
#         elif line[0] == "Type":
#             module["type"] = line[1]
#         elif line[0] == "Installed Size":
#             module["size"] = dmidecode_parse_size(line[1])
#         elif line[0] == "Enabled Size":
#             module["enabled_size"] = dmidecode_parse_size(line[1])
#         elif line[0] == "Current Speed":
#             time_sec = dmidecode_parse_time(line[1])
#             speed = 1.0 / time_sec
#             module["current_speed"] = speed


def inv_dmidecode_parse_physical_mem_array(lines: List[List[str]]) -> None:
    # We expect several possible arrays
    node = inv_tree_list("hardware.memory.arrays:")

    # If we have a dummy entry from previous Memory Devices (see below)
    # then we fill that entry rather than creating a new one
    if len(node) == 1 and list(node[0]) == ["devices"]:
        array = node[0]
    else:
        array = {"devices": []}
        node.append(array)

    array.update(
        _make_dict(
            lines, {
                "Location": "location",
                "Use": "use",
                "Error Correction Type": "error_correction",
                "Maximum Capacity": ("maximum_capacity", dmidecode_parse_size),
            }))


def inv_dmidecode_parse_mem_device(lines: List[List[str]]) -> None:

    device = _make_dict(
        lines,
        {
            "Total Width": "total_width",  # 64 bits
            "Data Width": "data_width",  # 64 bits
            "Form Factor": "form_factor",  # SODIMM
            "Set": "set",  # None
            "Locator": "locator",  # PROC 1 DIMM 2
            "Bank Locator": "bank_locator",  # Bank 2/3
            "Type": "type",  # DDR2
            "Type Detail": "type_detail",  # Synchronous
            "Manufacturer": "manufacturer",  # Not Specified
            "Serial Number": "serial",  # Not Specified
            "Asset Tag": "asset_tag",  # Not Specified
            "Part Number": "part_number",  # Not Specified
            "Speed": "speed",  # 667 MHz
            "Size": "size",  # 2048 MB
        },
    )

    # Do we already have an entry for a memory array? Then
    # we assume that this device belongs to the most recently
    # read array. Otherwise we create a dummy entry and replace
    # that later with actual information
    # If there are already arrays we try to find the right index of
    # the phy. array
    index = None
    if device.get("locator") and device["locator"].startswith("PROC"):
        index = device["locator"].split()[1]

    node = inv_tree_list("hardware.memory.arrays:")
    if node:
        try:
            array = node[int(index) - 1]
        except Exception:
            array = node[-1]
    else:
        array = {"devices": []}
        node.append(array)

    if device["size"] != "No Module Installed":
        # Convert speed and size into numbers
        device["speed"] = dmidecode_parse_speed(device.get("speed", "Unknown"))
        device["size"] = dmidecode_parse_size(device.get("size", "Unknown"))
        array["devices"].append(device)


def _make_dict(
    lines: List[List[str]],
    converter_map: Mapping[str, Converter],
) -> Dict[str, Union[float, str, None]]:
    dict_: Dict[str, Union[float, str, None]] = {}
    for name, raw_value, *_rest in lines:
        if name not in converter_map or raw_value == "Not Specified":
            continue

        converter = converter_map[name]
        if isinstance(converter, str):
            dict_[converter] = raw_value
            continue

        label, transform = converter
        value = transform(raw_value)
        if value is not None:
            dict_[label] = value

    return dict_


def dmidecode_parse_size(v: str) -> Optional[float]:  # into Bytes (int)
    if not v or v == "Unknown":
        return None

    parts = v.split()
    if parts[1].lower() == "tb":
        return int(parts[0]) * 1024 * 1024 * 1024 * 1024
    if parts[1].lower() == "gb":
        return int(parts[0]) * 1024 * 1024 * 1024
    if parts[1].lower() == "mb":
        return int(parts[0]) * 1024 * 1024
    if parts[1].lower() == "kb":
        return int(parts[0]) * 1024
    return int(parts[0])


def dmidecode_parse_speed(v: str) -> Optional[float]:  # into Hz (float)
    if not v or v == "Unknown":
        return None

    parts = v.split()
    if parts[1] == "GHz":
        return float(parts[0]) * 1000000000.0
    if parts[1] == "MHz":
        return float(parts[0]) * 1000000.0
    if parts[1] == "kHz":
        return float(parts[0]) * 1000.0
    if parts[1] == "Hz":
        return float(parts[0])
    return None


def dmidecode_parse_voltage(v: str) -> Optional[float]:
    if not v or v == "Unknown":
        return None
    return float(v.split()[0])


def dmidecode_parse_time(v: str) -> float:  # 155 ns
    parts = v.split()
    if parts[1] == "ns":
        return float(parts[0]) / 1000000000.0
    return float(parts[0])  # assume seconds


# TODO: bring this back CMK-5976
#
#inv_info['dmidecode'] = {
#    "inv_function": inv_dmidecode,
#}
